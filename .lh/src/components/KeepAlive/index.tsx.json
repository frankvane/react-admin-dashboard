{
    "sourceFile": "src/components/KeepAlive/index.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1742119559712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1742119584195,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n           },\n         ]);\n       }\n     }\n-  }, [children, location.pathname]);\n+  }, [location.pathname, cacheList]);\n \n   return (\n     <KeepAliveContext.Provider value={{ refresh }}>\n       {cacheList.map((item) => (\n"
                },
                {
                    "date": 1742119596087,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,46 +49,46 @@\n     const shouldCache = routeMeta?.keepAlive === true;\n \n     console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n \n-    // 检查当前路径是否已缓存\n-    const existingCache = cacheList.find((item) => item.key === currentPath);\n+    setCacheList((prevList) => {\n+      // 检查当前路径是否已缓存\n+      const existingCache = prevList.find((item) => item.key === currentPath);\n \n-    if (existingCache) {\n-      // 如果已缓存，则激活当前路径，停用其他路径\n-      setCacheList((prevList) =>\n-        prevList.map((item) => ({\n+      if (existingCache) {\n+        // 如果已缓存，则激活当前路径，停用其他路径\n+        return prevList.map((item) => ({\n           ...item,\n           active: item.key === currentPath,\n-        }))\n-      );\n-    } else {\n-      // 如果未缓存，则添加到缓存列表（如果需要缓存）\n-      // 或者替换之前的缓存（如果不需要缓存）\n-      if (shouldCache) {\n-        setCacheList((prevList) => [\n-          ...prevList.map((item) => ({\n-            ...item,\n-            active: false,\n-          })),\n-          {\n-            key: currentPath,\n-            component: children,\n-            active: true,\n-          },\n-        ]);\n+        }));\n       } else {\n-        // 如果不需要缓存，则只保留当前组件\n-        setCacheList([\n-          {\n-            key: currentPath,\n-            component: children,\n-            active: true,\n-          },\n-        ]);\n+        // 如果未缓存，则添加到缓存列表（如果需要缓存）\n+        // 或者替换之前的缓存（如果不需要缓存）\n+        if (shouldCache) {\n+          return [\n+            ...prevList.map((item) => ({\n+              ...item,\n+              active: false,\n+            })),\n+            {\n+              key: currentPath,\n+              component: children,\n+              active: true,\n+            },\n+          ];\n+        } else {\n+          // 如果不需要缓存，则只保留当前组件\n+          return [\n+            {\n+              key: currentPath,\n+              component: children,\n+              active: true,\n+            },\n+          ];\n+        }\n       }\n-    }\n-  }, [location.pathname, cacheList]);\n+    });\n+  }, [location.pathname, children]);\n \n   return (\n     <KeepAliveContext.Provider value={{ refresh }}>\n       {cacheList.map((item) => (\n"
                },
                {
                    "date": 1742119614842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import React, { createContext, useEffect, useState } from \"react\";\n+import React, { createContext, useEffect, useRef, useState } from \"react\";\n \n import { getRouteMetaByPath } from \"../../router/routes\";\n import useCacheStore from \"../../store/cacheStore\";\n import { useLocation } from \"react-router-dom\";\n@@ -28,9 +28,15 @@\n const KeepAlive: React.FC<KeepAliveProps> = ({ children }) => {\n   const location = useLocation();\n   const [cacheList, setCacheList] = useState<CacheItem[]>([]);\n   const { clearCache } = useCacheStore();\n+  const childrenRef = useRef(children);\n \n+  // 更新childrenRef\n+  useEffect(() => {\n+    childrenRef.current = children;\n+  }, [children]);\n+\n   // 刷新指定路径的缓存\n   const refresh = (path: string) => {\n     console.log(`KeepAlive: 刷新路径 ${path} 的缓存`);\n \n@@ -70,25 +76,25 @@\n               active: false,\n             })),\n             {\n               key: currentPath,\n-              component: children,\n+              component: childrenRef.current,\n               active: true,\n             },\n           ];\n         } else {\n           // 如果不需要缓存，则只保留当前组件\n           return [\n             {\n               key: currentPath,\n-              component: children,\n+              component: childrenRef.current,\n               active: true,\n             },\n           ];\n         }\n       }\n     });\n-  }, [location.pathname, children]);\n+  }, [location.pathname]);\n \n   return (\n     <KeepAliveContext.Provider value={{ refresh }}>\n       {cacheList.map((item) => (\n"
                },
                {
                    "date": 1742119798446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,108 +1,112 @@\n-import React, { createContext, useEffect, useRef, useState } from \"react\";\n+import React, { createContext, useContext, useEffect, useRef, useState } from \"react\";\n \n-import { getRouteMetaByPath } from \"../../router/routes\";\n-import useCacheStore from \"../../store/cacheStore\";\n+import { getRouteMetaByPath } from \"@/router/routes\";\n import { useLocation } from \"react-router-dom\";\n \n // 缓存项接口\n interface CacheItem {\n   key: string;\n   component: React.ReactNode;\n-  active: boolean;\n }\n \n-// 缓存上下文接口\n+// KeepAlive上下文接口\n interface KeepAliveContextType {\n   refresh: (path: string) => void;\n+  cacheItems: Map<string, React.ReactNode>;\n }\n \n-// 创建缓存上下文\n+// 创建KeepAlive上下文\n export const KeepAliveContext = createContext<KeepAliveContextType>({\n   refresh: () => {},\n+  cacheItems: new Map()\n });\n \n+// 使用KeepAlive上下文的Hook\n+export const useKeepAlive = () => useContext(KeepAliveContext);\n+\n interface KeepAliveProps {\n   children: React.ReactNode;\n }\n \n const KeepAlive: React.FC<KeepAliveProps> = ({ children }) => {\n   const location = useLocation();\n-  const [cacheList, setCacheList] = useState<CacheItem[]>([]);\n-  const { clearCache } = useCacheStore();\n+  const currentPath = location.pathname;\n+  const [activeKey, setActiveKey] = useState(currentPath);\n+  \n+  // 使用Map存储缓存的组件\n+  const [cacheItems, setCacheItems] = useState<Map<string, React.ReactNode>>(new Map());\n+  \n+  // 使用ref存储当前children，避免不必要的重渲染\n   const childrenRef = useRef(children);\n-\n-  // 更新childrenRef\n   useEffect(() => {\n     childrenRef.current = children;\n   }, [children]);\n \n   // 刷新指定路径的缓存\n   const refresh = (path: string) => {\n     console.log(`KeepAlive: 刷新路径 ${path} 的缓存`);\n-\n-    // 从缓存列表中移除该路径\n-    setCacheList((prevList) => {\n-      return prevList.filter((item) => item.key !== path);\n+    setCacheItems(prev => {\n+      const newCache = new Map(prev);\n+      newCache.delete(path);\n+      return newCache;\n     });\n-\n-    // 使用 Zustand store 通知其他组件缓存已清除\n-    clearCache(path);\n   };\n \n+  // 当路径变化时更新缓存\n   useEffect(() => {\n-    const currentPath = location.pathname;\n     const routeMeta = getRouteMetaByPath(currentPath);\n     const shouldCache = routeMeta?.keepAlive === true;\n-\n+    \n     console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n+    \n+    setActiveKey(currentPath);\n+    \n+    // 如果需要缓存，则添加到缓存Map中\n+    if (shouldCache) {\n+      setCacheItems(prev => {\n+        // 如果已经有缓存，不需要更新\n+        if (prev.has(currentPath)) {\n+          return prev;\n+        }\n+        \n+        // 否则添加新缓存\n+        const newCache = new Map(prev);\n+        newCache.set(currentPath, childrenRef.current);\n+        return newCache;\n+      });\n+    } else {\n+      // 如果不需要缓存，则从缓存中移除\n+      setCacheItems(prev => {\n+        if (!prev.has(currentPath)) {\n+          return prev;\n+        }\n+        \n+        const newCache = new Map(prev);\n+        newCache.delete(currentPath);\n+        return newCache;\n+      });\n+    }\n+  }, [currentPath]);\n \n-    setCacheList((prevList) => {\n-      // 检查当前路径是否已缓存\n-      const existingCache = prevList.find((item) => item.key === currentPath);\n+  // 渲染当前活动组件或缓存的组件\n+  const renderContent = () => {\n+    // 如果当前路径在缓存中，则使用缓存的组件\n+    if (cacheItems.has(activeKey)) {\n+      return Array.from(cacheItems.entries()).map(([key, component]) => (\n+        <div key={key} style={{ display: key === activeKey ? 'block' : 'none' }}>\n+          {component}\n+        </div>\n+      ));\n+    }\n+    \n+    // 否则直接渲染当前组件\n+    return <div>{children}</div>;\n+  };\n \n-      if (existingCache) {\n-        // 如果已缓存，则激活当前路径，停用其他路径\n-        return prevList.map((item) => ({\n-          ...item,\n-          active: item.key === currentPath,\n-        }));\n-      } else {\n-        // 如果未缓存，则添加到缓存列表（如果需要缓存）\n-        // 或者替换之前的缓存（如果不需要缓存）\n-        if (shouldCache) {\n-          return [\n-            ...prevList.map((item) => ({\n-              ...item,\n-              active: false,\n-            })),\n-            {\n-              key: currentPath,\n-              component: childrenRef.current,\n-              active: true,\n-            },\n-          ];\n-        } else {\n-          // 如果不需要缓存，则只保留当前组件\n-          return [\n-            {\n-              key: currentPath,\n-              component: childrenRef.current,\n-              active: true,\n-            },\n-          ];\n-        }\n-      }\n-    });\n-  }, [location.pathname]);\n-\n   return (\n-    <KeepAliveContext.Provider value={{ refresh }}>\n-      {cacheList.map((item) => (\n-        <div key={item.key} style={{ display: item.active ? \"block\" : \"none\" }}>\n-          {item.component}\n-        </div>\n-      ))}\n+    <KeepAliveContext.Provider value={{ refresh, cacheItems }}>\n+      {renderContent()}\n     </KeepAliveContext.Provider>\n   );\n };\n \n"
                },
                {
                    "date": 1742119816938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,11 @@\n-import React, { createContext, useContext, useEffect, useRef, useState } from \"react\";\n+import React, {\n+  createContext,\n+  useContext,\n+  useEffect,\n+  useRef,\n+  useState,\n+} from \"react\";\n \n import { getRouteMetaByPath } from \"@/router/routes\";\n import { useLocation } from \"react-router-dom\";\n \n@@ -17,9 +23,9 @@\n \n // 创建KeepAlive上下文\n export const KeepAliveContext = createContext<KeepAliveContextType>({\n   refresh: () => {},\n-  cacheItems: new Map()\n+  cacheItems: new Map(),\n });\n \n // 使用KeepAlive上下文的Hook\n export const useKeepAlive = () => useContext(KeepAliveContext);\n@@ -31,12 +37,14 @@\n const KeepAlive: React.FC<KeepAliveProps> = ({ children }) => {\n   const location = useLocation();\n   const currentPath = location.pathname;\n   const [activeKey, setActiveKey] = useState(currentPath);\n-  \n+\n   // 使用Map存储缓存的组件\n-  const [cacheItems, setCacheItems] = useState<Map<string, React.ReactNode>>(new Map());\n-  \n+  const [cacheItems, setCacheItems] = useState<Map<string, React.ReactNode>>(\n+    new Map()\n+  );\n+\n   // 使用ref存储当前children，避免不必要的重渲染\n   const childrenRef = useRef(children);\n   useEffect(() => {\n     childrenRef.current = children;\n@@ -44,9 +52,9 @@\n \n   // 刷新指定路径的缓存\n   const refresh = (path: string) => {\n     console.log(`KeepAlive: 刷新路径 ${path} 的缓存`);\n-    setCacheItems(prev => {\n+    setCacheItems((prev) => {\n       const newCache = new Map(prev);\n       newCache.delete(path);\n       return newCache;\n     });\n@@ -55,33 +63,33 @@\n   // 当路径变化时更新缓存\n   useEffect(() => {\n     const routeMeta = getRouteMetaByPath(currentPath);\n     const shouldCache = routeMeta?.keepAlive === true;\n-    \n+\n     console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n-    \n+\n     setActiveKey(currentPath);\n-    \n+\n     // 如果需要缓存，则添加到缓存Map中\n     if (shouldCache) {\n-      setCacheItems(prev => {\n+      setCacheItems((prev) => {\n         // 如果已经有缓存，不需要更新\n         if (prev.has(currentPath)) {\n           return prev;\n         }\n-        \n+\n         // 否则添加新缓存\n         const newCache = new Map(prev);\n         newCache.set(currentPath, childrenRef.current);\n         return newCache;\n       });\n     } else {\n       // 如果不需要缓存，则从缓存中移除\n-      setCacheItems(prev => {\n+      setCacheItems((prev) => {\n         if (!prev.has(currentPath)) {\n           return prev;\n         }\n-        \n+\n         const newCache = new Map(prev);\n         newCache.delete(currentPath);\n         return newCache;\n       });\n@@ -92,14 +100,17 @@\n   const renderContent = () => {\n     // 如果当前路径在缓存中，则使用缓存的组件\n     if (cacheItems.has(activeKey)) {\n       return Array.from(cacheItems.entries()).map(([key, component]) => (\n-        <div key={key} style={{ display: key === activeKey ? 'block' : 'none' }}>\n+        <div\n+          key={key}\n+          style={{ display: key === activeKey ? \"block\" : \"none\" }}\n+        >\n           {component}\n         </div>\n       ));\n     }\n-    \n+\n     // 否则直接渲染当前组件\n     return <div>{children}</div>;\n   };\n \n@@ -109,5 +120,5 @@\n     </KeepAliveContext.Provider>\n   );\n };\n \n-export default KeepAlive;\n\\ No newline at end of file\n+export default KeepAlive;\n"
                },
                {
                    "date": 1742119824792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,5 @@\n-import React, {\n-  createContext,\n-  useContext,\n-  useEffect,\n-  useRef,\n-  useState,\n-} from \"react\";\n+import React, { createContext, useContext, useEffect, useRef, useState } from \"react\";\n \n import { getRouteMetaByPath } from \"@/router/routes\";\n import { useLocation } from \"react-router-dom\";\n \n@@ -23,9 +17,9 @@\n \n // 创建KeepAlive上下文\n export const KeepAliveContext = createContext<KeepAliveContextType>({\n   refresh: () => {},\n-  cacheItems: new Map(),\n+  cacheItems: new Map()\n });\n \n // 使用KeepAlive上下文的Hook\n export const useKeepAlive = () => useContext(KeepAliveContext);\n@@ -37,14 +31,12 @@\n const KeepAlive: React.FC<KeepAliveProps> = ({ children }) => {\n   const location = useLocation();\n   const currentPath = location.pathname;\n   const [activeKey, setActiveKey] = useState(currentPath);\n-\n+  \n   // 使用Map存储缓存的组件\n-  const [cacheItems, setCacheItems] = useState<Map<string, React.ReactNode>>(\n-    new Map()\n-  );\n-\n+  const [cacheItems, setCacheItems] = useState<Map<string, React.ReactNode>>(new Map());\n+  \n   // 使用ref存储当前children，避免不必要的重渲染\n   const childrenRef = useRef(children);\n   useEffect(() => {\n     childrenRef.current = children;\n@@ -52,9 +44,9 @@\n \n   // 刷新指定路径的缓存\n   const refresh = (path: string) => {\n     console.log(`KeepAlive: 刷新路径 ${path} 的缓存`);\n-    setCacheItems((prev) => {\n+    setCacheItems(prev => {\n       const newCache = new Map(prev);\n       newCache.delete(path);\n       return newCache;\n     });\n@@ -63,33 +55,33 @@\n   // 当路径变化时更新缓存\n   useEffect(() => {\n     const routeMeta = getRouteMetaByPath(currentPath);\n     const shouldCache = routeMeta?.keepAlive === true;\n-\n+    \n     console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n-\n+    \n     setActiveKey(currentPath);\n-\n+    \n     // 如果需要缓存，则添加到缓存Map中\n     if (shouldCache) {\n-      setCacheItems((prev) => {\n+      setCacheItems(prev => {\n         // 如果已经有缓存，不需要更新\n         if (prev.has(currentPath)) {\n           return prev;\n         }\n-\n+        \n         // 否则添加新缓存\n         const newCache = new Map(prev);\n         newCache.set(currentPath, childrenRef.current);\n         return newCache;\n       });\n     } else {\n       // 如果不需要缓存，则从缓存中移除\n-      setCacheItems((prev) => {\n+      setCacheItems(prev => {\n         if (!prev.has(currentPath)) {\n           return prev;\n         }\n-\n+        \n         const newCache = new Map(prev);\n         newCache.delete(currentPath);\n         return newCache;\n       });\n@@ -100,17 +92,14 @@\n   const renderContent = () => {\n     // 如果当前路径在缓存中，则使用缓存的组件\n     if (cacheItems.has(activeKey)) {\n       return Array.from(cacheItems.entries()).map(([key, component]) => (\n-        <div\n-          key={key}\n-          style={{ display: key === activeKey ? \"block\" : \"none\" }}\n-        >\n+        <div key={key} style={{ display: key === activeKey ? 'block' : 'none' }}>\n           {component}\n         </div>\n       ));\n     }\n-\n+    \n     // 否则直接渲染当前组件\n     return <div>{children}</div>;\n   };\n \n"
                },
                {
                    "date": 1742119860840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,11 @@\n-import React, { createContext, useContext, useEffect, useRef, useState } from \"react\";\n+import React, {\n+  createContext,\n+  useContext,\n+  useEffect,\n+  useRef,\n+  useState,\n+} from \"react\";\n \n import { getRouteMetaByPath } from \"@/router/routes\";\n import { useLocation } from \"react-router-dom\";\n \n@@ -17,9 +23,9 @@\n \n // 创建KeepAlive上下文\n export const KeepAliveContext = createContext<KeepAliveContextType>({\n   refresh: () => {},\n-  cacheItems: new Map()\n+  cacheItems: new Map(),\n });\n \n // 使用KeepAlive上下文的Hook\n export const useKeepAlive = () => useContext(KeepAliveContext);\n@@ -31,12 +37,14 @@\n const KeepAlive: React.FC<KeepAliveProps> = ({ children }) => {\n   const location = useLocation();\n   const currentPath = location.pathname;\n   const [activeKey, setActiveKey] = useState(currentPath);\n-  \n+\n   // 使用Map存储缓存的组件\n-  const [cacheItems, setCacheItems] = useState<Map<string, React.ReactNode>>(new Map());\n-  \n+  const [cacheItems, setCacheItems] = useState<Map<string, React.ReactNode>>(\n+    new Map()\n+  );\n+\n   // 使用ref存储当前children，避免不必要的重渲染\n   const childrenRef = useRef(children);\n   useEffect(() => {\n     childrenRef.current = children;\n@@ -44,9 +52,9 @@\n \n   // 刷新指定路径的缓存\n   const refresh = (path: string) => {\n     console.log(`KeepAlive: 刷新路径 ${path} 的缓存`);\n-    setCacheItems(prev => {\n+    setCacheItems((prev) => {\n       const newCache = new Map(prev);\n       newCache.delete(path);\n       return newCache;\n     });\n@@ -55,33 +63,33 @@\n   // 当路径变化时更新缓存\n   useEffect(() => {\n     const routeMeta = getRouteMetaByPath(currentPath);\n     const shouldCache = routeMeta?.keepAlive === true;\n-    \n+\n     console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n-    \n+\n     setActiveKey(currentPath);\n-    \n+\n     // 如果需要缓存，则添加到缓存Map中\n     if (shouldCache) {\n-      setCacheItems(prev => {\n+      setCacheItems((prev) => {\n         // 如果已经有缓存，不需要更新\n         if (prev.has(currentPath)) {\n           return prev;\n         }\n-        \n+\n         // 否则添加新缓存\n         const newCache = new Map(prev);\n         newCache.set(currentPath, childrenRef.current);\n         return newCache;\n       });\n     } else {\n       // 如果不需要缓存，则从缓存中移除\n-      setCacheItems(prev => {\n+      setCacheItems((prev) => {\n         if (!prev.has(currentPath)) {\n           return prev;\n         }\n-        \n+\n         const newCache = new Map(prev);\n         newCache.delete(currentPath);\n         return newCache;\n       });\n@@ -92,14 +100,17 @@\n   const renderContent = () => {\n     // 如果当前路径在缓存中，则使用缓存的组件\n     if (cacheItems.has(activeKey)) {\n       return Array.from(cacheItems.entries()).map(([key, component]) => (\n-        <div key={key} style={{ display: key === activeKey ? 'block' : 'none' }}>\n+        <div\n+          key={key}\n+          style={{ display: key === activeKey ? \"block\" : \"none\" }}\n+        >\n           {component}\n         </div>\n       ));\n     }\n-    \n+\n     // 否则直接渲染当前组件\n     return <div>{children}</div>;\n   };\n \n"
                },
                {
                    "date": 1742119922355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,31 +1,25 @@\n import React, {\n   createContext,\n+  useCallback,\n   useContext,\n   useEffect,\n+  useMemo,\n   useRef,\n   useState,\n } from \"react\";\n \n import { getRouteMetaByPath } from \"@/router/routes\";\n import { useLocation } from \"react-router-dom\";\n \n-// 缓存项接口\n-interface CacheItem {\n-  key: string;\n-  component: React.ReactNode;\n-}\n-\n // KeepAlive上下文接口\n interface KeepAliveContextType {\n   refresh: (path: string) => void;\n-  cacheItems: Map<string, React.ReactNode>;\n }\n \n // 创建KeepAlive上下文\n export const KeepAliveContext = createContext<KeepAliveContextType>({\n   refresh: () => {},\n-  cacheItems: new Map(),\n });\n \n // 使用KeepAlive上下文的Hook\n export const useKeepAlive = () => useContext(KeepAliveContext);\n@@ -33,91 +27,68 @@\n interface KeepAliveProps {\n   children: React.ReactNode;\n }\n \n+// 缓存组件包装器\n+const CachedComponent = React.memo(\n+  ({ children }: { children: React.ReactNode }) => {\n+    console.log(\"Rendering cached component\");\n+    return <>{children}</>;\n+  }\n+);\n+\n const KeepAlive: React.FC<KeepAliveProps> = ({ children }) => {\n   const location = useLocation();\n   const currentPath = location.pathname;\n-  const [activeKey, setActiveKey] = useState(currentPath);\n-\n-  // 使用Map存储缓存的组件\n-  const [cacheItems, setCacheItems] = useState<Map<string, React.ReactNode>>(\n-    new Map()\n-  );\n-\n-  // 使用ref存储当前children，避免不必要的重渲染\n-  const childrenRef = useRef(children);\n-  useEffect(() => {\n-    childrenRef.current = children;\n-  }, [children]);\n-\n+  \n+  // 使用对象存储缓存的组件，键为路径，值为组件\n+  const [cache, setCache] = useState<Record<string, React.ReactNode>>({});\n+  \n+  // 当前活动路径\n+  const [activePath, setActivePath] = useState(currentPath);\n+  \n   // 刷新指定路径的缓存\n-  const refresh = (path: string) => {\n+  const refresh = useCallback((path: string) => {\n     console.log(`KeepAlive: 刷新路径 ${path} 的缓存`);\n-    setCacheItems((prev) => {\n-      const newCache = new Map(prev);\n-      newCache.delete(path);\n+    setCache(prev => {\n+      const newCache = { ...prev };\n+      delete newCache[path];\n       return newCache;\n     });\n-  };\n+  }, []);\n \n   // 当路径变化时更新缓存\n   useEffect(() => {\n     const routeMeta = getRouteMetaByPath(currentPath);\n     const shouldCache = routeMeta?.keepAlive === true;\n-\n+    \n     console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n-\n-    setActiveKey(currentPath);\n-\n-    // 如果需要缓存，则添加到缓存Map中\n-    if (shouldCache) {\n-      setCacheItems((prev) => {\n-        // 如果已经有缓存，不需要更新\n-        if (prev.has(currentPath)) {\n-          return prev;\n-        }\n-\n-        // 否则添加新缓存\n-        const newCache = new Map(prev);\n-        newCache.set(currentPath, childrenRef.current);\n-        return newCache;\n-      });\n-    } else {\n-      // 如果不需要缓存，则从缓存中移除\n-      setCacheItems((prev) => {\n-        if (!prev.has(currentPath)) {\n-          return prev;\n-        }\n-\n-        const newCache = new Map(prev);\n-        newCache.delete(currentPath);\n-        return newCache;\n-      });\n+    \n+    setActivePath(currentPath);\n+    \n+    if (shouldCache && !cache[currentPath]) {\n+      // 如果需要缓存且尚未缓存，则添加到缓存中\n+      setCache(prev => ({\n+        ...prev,\n+        [currentPath]: <CachedComponent>{children}</CachedComponent>\n+      }));\n     }\n-  }, [currentPath]);\n+  }, [currentPath, children, cache]);\n \n-  // 渲染当前活动组件或缓存的组件\n-  const renderContent = () => {\n+  // 使用useMemo缓存渲染结果\n+  const content = useMemo(() => {\n     // 如果当前路径在缓存中，则使用缓存的组件\n-    if (cacheItems.has(activeKey)) {\n-      return Array.from(cacheItems.entries()).map(([key, component]) => (\n-        <div\n-          key={key}\n-          style={{ display: key === activeKey ? \"block\" : \"none\" }}\n-        >\n-          {component}\n-        </div>\n-      ));\n+    if (cache[activePath]) {\n+      return cache[activePath];\n     }\n-\n+    \n     // 否则直接渲染当前组件\n-    return <div>{children}</div>;\n-  };\n+    return children;\n+  }, [activePath, cache, children]);\n \n   return (\n-    <KeepAliveContext.Provider value={{ refresh, cacheItems }}>\n-      {renderContent()}\n+    <KeepAliveContext.Provider value={{ refresh }}>\n+      {content}\n     </KeepAliveContext.Provider>\n   );\n };\n \n"
                },
                {
                    "date": 1742119930186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,8 @@\n   useCallback,\n   useContext,\n   useEffect,\n   useMemo,\n-  useRef,\n   useState,\n } from \"react\";\n \n import { getRouteMetaByPath } from \"@/router/routes\";\n"
                },
                {
                    "date": 1742119955740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,21 +58,21 @@\n   // 当路径变化时更新缓存\n   useEffect(() => {\n     const routeMeta = getRouteMetaByPath(currentPath);\n     const shouldCache = routeMeta?.keepAlive === true;\n-\n+    \n     console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n-\n+    \n     setActivePath(currentPath);\n-\n+    \n     if (shouldCache && !cache[currentPath]) {\n       // 如果需要缓存且尚未缓存，则添加到缓存中\n-      setCache((prev) => ({\n+      setCache(prev => ({\n         ...prev,\n-        [currentPath]: <CachedComponent>{children}</CachedComponent>,\n+        [currentPath]: <CachedComponent>{children}</CachedComponent>\n       }));\n     }\n-  }, [currentPath, children, cache]);\n+  }, [currentPath, children]);  // 移除cache依赖项\n \n   // 使用useMemo缓存渲染结果\n   const content = useMemo(() => {\n     // 如果当前路径在缓存中，则使用缓存的组件\n"
                },
                {
                    "date": 1742119974317,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,9 @@\n   useCallback,\n   useContext,\n   useEffect,\n   useMemo,\n+  useRef,\n   useState,\n } from \"react\";\n \n import { getRouteMetaByPath } from \"@/router/routes\";\n@@ -38,22 +39,25 @@\n const KeepAlive: React.FC<KeepAliveProps> = ({ children }) => {\n   const location = useLocation();\n   const currentPath = location.pathname;\n \n-  // 使用对象存储缓存的组件，键为路径，值为组件\n-  const [cache, setCache] = useState<Record<string, React.ReactNode>>({});\n+  // 使用ref存储缓存，避免状态更新导致的重渲染\n+  const cacheRef = useRef<Record<string, React.ReactNode>>({});\n \n   // 当前活动路径\n   const [activePath, setActivePath] = useState(currentPath);\n \n+  // 强制更新组件的状态\n+  const [, forceUpdate] = useState({});\n+\n   // 刷新指定路径的缓存\n   const refresh = useCallback((path: string) => {\n     console.log(`KeepAlive: 刷新路径 ${path} 的缓存`);\n-    setCache((prev) => {\n-      const newCache = { ...prev };\n-      delete newCache[path];\n-      return newCache;\n-    });\n+    if (cacheRef.current[path]) {\n+      delete cacheRef.current[path];\n+      // 强制更新组件\n+      forceUpdate({});\n+    }\n   }, []);\n \n   // 当路径变化时更新缓存\n   useEffect(() => {\n@@ -63,27 +67,26 @@\n     console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n \n     setActivePath(currentPath);\n \n-    if (shouldCache && !cache[currentPath]) {\n+    if (shouldCache && !cacheRef.current[currentPath]) {\n       // 如果需要缓存且尚未缓存，则添加到缓存中\n-      setCache((prev) => ({\n-        ...prev,\n-        [currentPath]: <CachedComponent>{children}</CachedComponent>,\n-      }));\n+      cacheRef.current[currentPath] = <CachedComponent>{children}</CachedComponent>;\n+      // 强制更新组件\n+      forceUpdate({});\n     }\n-  }, [currentPath, children]); // 移除cache依赖项\n+  }, [currentPath, children]);\n \n   // 使用useMemo缓存渲染结果\n   const content = useMemo(() => {\n     // 如果当前路径在缓存中，则使用缓存的组件\n-    if (cache[activePath]) {\n-      return cache[activePath];\n+    if (cacheRef.current[activePath]) {\n+      return cacheRef.current[activePath];\n     }\n \n     // 否则直接渲染当前组件\n     return children;\n-  }, [activePath, cache, children]);\n+  }, [activePath, children, cacheRef.current]);\n \n   return (\n     <KeepAliveContext.Provider value={{ refresh }}>\n       {content}\n"
                }
            ],
            "date": 1742119559712,
            "name": "Commit-0",
            "content": "import React, { createContext, useEffect, useState } from \"react\";\n\nimport { getRouteMetaByPath } from \"../../router/routes\";\nimport useCacheStore from \"../../store/cacheStore\";\nimport { useLocation } from \"react-router-dom\";\n\n// 缓存项接口\ninterface CacheItem {\n  key: string;\n  component: React.ReactNode;\n  active: boolean;\n}\n\n// 缓存上下文接口\ninterface KeepAliveContextType {\n  refresh: (path: string) => void;\n}\n\n// 创建缓存上下文\nexport const KeepAliveContext = createContext<KeepAliveContextType>({\n  refresh: () => {},\n});\n\ninterface KeepAliveProps {\n  children: React.ReactNode;\n}\n\nconst KeepAlive: React.FC<KeepAliveProps> = ({ children }) => {\n  const location = useLocation();\n  const [cacheList, setCacheList] = useState<CacheItem[]>([]);\n  const { clearCache } = useCacheStore();\n\n  // 刷新指定路径的缓存\n  const refresh = (path: string) => {\n    console.log(`KeepAlive: 刷新路径 ${path} 的缓存`);\n\n    // 从缓存列表中移除该路径\n    setCacheList((prevList) => {\n      return prevList.filter((item) => item.key !== path);\n    });\n\n    // 使用 Zustand store 通知其他组件缓存已清除\n    clearCache(path);\n  };\n\n  useEffect(() => {\n    const currentPath = location.pathname;\n    const routeMeta = getRouteMetaByPath(currentPath);\n    const shouldCache = routeMeta?.keepAlive === true;\n\n    console.log(`Path: ${currentPath}, Should cache: ${shouldCache}`);\n\n    // 检查当前路径是否已缓存\n    const existingCache = cacheList.find((item) => item.key === currentPath);\n\n    if (existingCache) {\n      // 如果已缓存，则激活当前路径，停用其他路径\n      setCacheList((prevList) =>\n        prevList.map((item) => ({\n          ...item,\n          active: item.key === currentPath,\n        }))\n      );\n    } else {\n      // 如果未缓存，则添加到缓存列表（如果需要缓存）\n      // 或者替换之前的缓存（如果不需要缓存）\n      if (shouldCache) {\n        setCacheList((prevList) => [\n          ...prevList.map((item) => ({\n            ...item,\n            active: false,\n          })),\n          {\n            key: currentPath,\n            component: children,\n            active: true,\n          },\n        ]);\n      } else {\n        // 如果不需要缓存，则只保留当前组件\n        setCacheList([\n          {\n            key: currentPath,\n            component: children,\n            active: true,\n          },\n        ]);\n      }\n    }\n  }, [children, location.pathname]);\n\n  return (\n    <KeepAliveContext.Provider value={{ refresh }}>\n      {cacheList.map((item) => (\n        <div key={item.key} style={{ display: item.active ? \"block\" : \"none\" }}>\n          {item.component}\n        </div>\n      ))}\n    </KeepAliveContext.Provider>\n  );\n};\n\nexport default KeepAlive;"
        }
    ]
}